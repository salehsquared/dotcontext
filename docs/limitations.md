# Limitations

dotcontext is honest about what it does and doesn't guarantee. This page documents known boundaries.

## AST Export Detection

Export detection uses tree-sitter for accurate AST parsing, but only for 5 languages. Everything else falls back to regex.

| Depth | Languages | Method |
|---|---|---|
| Full AST | TypeScript, JavaScript, Python, Go, Rust | tree-sitter queries with language-specific filters |
| Regex fallback | Java, Kotlin, C, C++, Ruby, PHP, Swift, Scala, and all others | Pattern matching on `export`, `pub`, `def`, `func`, etc. |
| Skipped | Binary files, images, minified code | Not analyzed |

**Consequence:** `validate --strict` phantom interface checks are reliable for the 5 tree-sitter languages. For others, the regex fallback may miss complex export patterns (e.g., Java annotations, Ruby metaprogramming, PHP traits).

**Consequence:** Static-mode `interfaces` listings are most accurate for TypeScript/JavaScript/Python/Go/Rust. For other languages, LLM mode (`--llm`) will produce better interface descriptions.

## Fingerprinting

Fingerprints are **mtime-based, not content-based**:

```
fingerprint = SHA256(sorted(filename:mtime:size))[:8]
```

| Scenario | Result |
|---|---|
| File content changes | Stale (mtime updates) |
| File touched without content change | Stale (mtime updates) |
| File reverted to identical content | Stale (new mtime) |
| Same content, different machines | Different fingerprints (different mtimes) |
| `git checkout` of same commit | May produce different fingerprints |

This is a deliberate tradeoff. `stat()` is fast (no file reads). Content hashing would require reading every file in every directory on every check — expensive for large projects.

**Practical impact:** Occasional false staleness. Run `context rehash` after bulk operations that touch mtimes without changing content (e.g., `git checkout`, `touch`, build tools that rewrite files).

## LLM Narratives

Fields generated by LLMs (`summary`, `decisions`, `constraints`, `current_state`, LLM-mode `interfaces`) are **narrative, not verified fact**.

- LLMs may hallucinate interface descriptions
- LLMs may mischaracterize architectural decisions
- LLMs may miss constraints or invent ones that don't exist
- Summaries may be overly generic or miss key functionality

The `derived_fields` array in each context file lists which fields are machine-derived ground truth vs LLM narrative. See [trust-model.md](trust-model.md).

**Mitigation:** Use `validate --strict` to catch drift. Cross-reference with actual code for critical decisions. Static mode (`--no-llm`) avoids LLM narrative, but still includes heuristic summaries that should be treated as high-confidence guidance, not formal proof.

## Strict Mode Dependency Cross-Check

The `validate --strict` dependency cross-check **only runs when `dependencies.internal` has at least one entry**. If the field is absent or empty, undeclared imports won't be flagged.

This is intentional: static-generated context files often don't populate internal deps. Flagging every import as "undeclared" when no deps are declared would produce overwhelming noise. The cross-check is useful for verifying that an existing dep list is complete — not for discovering deps from scratch.

**If you want comprehensive dependency checking:** ensure your context files have `dependencies.internal` populated (LLM mode does this, or add manually).

## Evidence Collection

Evidence is **read-only** — dotcontext never runs test commands or linters. It only reads existing artifact files.

| What it reads | Format |
|---|---|
| `test-results.json` | Jest/Vitest JSON format |
| `.vitest-results.json` | Vitest JSON format |
| `junit.xml` | JUnit XML format |

**Limitations:**
- If test artifacts are from a previous run, evidence reflects that old run
- Root-level only — evidence does not appear in subdirectory contexts
- Opt-in via `--evidence` flag — not collected by default
- JUnit XML parsing uses regex, not a full XML parser — complex JUnit files may not parse correctly

## Watch Mode

`context watch` scans the project directory tree **once at startup** and monitors only those directories.

- New directories created while watching won't be tracked
- Deleted directories will produce errors on the next check (handled gracefully)
- Restart `context watch` after structural changes to the project

## Token Threshold Filtering (`min_tokens`)

dotcontext applies a directory token threshold during scanning (default: `min_tokens: 4096`).

- Directories below threshold are skipped unless needed to preserve parent-child routing context
- This affects command scope for `status`, `validate`, `watch`, and MCP `list_contexts`
- A directory may contain source files but still have no `.context.yaml` if it is below threshold

**If you need full coverage:** set `min_tokens: 0` in `.context.config.yaml` to disable threshold filtering.

## Ignore Patterns

The scanner supports common ignore patterns but is **not a full .gitignore implementation**.

**Supported:**
- Exact directory names: `dist`, `node_modules`
- Glob wildcards: `*.cache`, `.*.swp`
- Path patterns: `src/generated`, `packages/*/dist`
- Double-star: `**/temp`
- Negation: `!important-build`
- Trailing slash stripping: `build/` treated as `build`

**Not supported:**
- Per-directory `.gitignore` files (only reads `.gitignore` at project root)
- Character class ranges: `[abc]`, `[0-9]`
- Trailing `/**` for "everything inside a directory"
- Comments within patterns (lines starting with `#` are skipped, but inline `#` is not handled)

## Concurrency

dotcontext is designed for single-developer use. No file locking or conflict resolution beyond standard git.

- Two LLMs editing the same `.context.yaml` simultaneously may produce conflicts
- Standard git conflict resolution applies (these are text files)
- No distributed locking or coordination protocol

## Scale

Tested on projects with hundreds of directories and thousands of files. Known scaling considerations:

- Tree-sitter initialization has a one-time cost (~200ms for WASM loading)
- LLM generation is the bottleneck — one API call per directory
- Static mode is fast (< 1 second for typical projects)
- `maxDepth` config caps directory traversal to prevent runaway scanning
